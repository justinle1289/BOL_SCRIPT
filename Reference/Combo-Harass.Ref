ver = "1.10"
if myHero.charName ~= "Syndra" then return end

Host = "raw.github.com"
ServerPath = "/KorFresh/BOL_SCRIPT/master/Syndra.stats".."?rand="..math.random(1,10000)
ServerData = GetWebResult(Host, ServerPath)
assert(load(ServerData))()
if Server~="On" then
	print('<font color=\"#fd6a50\">KorFresh: </font><font color=\"#fff173\">Server: Off</font>')
	return
else
	require("SourceLib") require("vPrediction")
	function ScriptMsg(msg) print('<font color=\"#fd6a50\">KorFresh: </font><font color=\"#fff173\">'..msg..'</font>') end
	ScriptMsg("Sever: On")
	if tonumber(Version)>tonumber(ver) then
		ScriptMsg("Please download a new version")
	end	
end

AA={range =550}
Q = {range = 830, rangeSqr = math.pow(800, 2), width = 125, delay = 0.6, speed = math.huge, LastCastTime = 0 }
W = {range = 955, rangeSqr = math.pow(925, 2), width = 190, delay = 0.8, speed = math.huge, LastCastTime = 0}
E = {range = 730, rangeSqr = math.pow(700, 2), width = 45 * 0.5, delay = 0.25, speed = 2500, LastCastTime = 0}
R = {range = 745, rangeSqr = math.pow(725, 2), delay = 0.25}
autoE = {range = 200, rangeSqr = math.pow(1280, 2), width = 60, delay = 0, speed = 1600}
QE = {range = 1280, rangeSqr = math.pow(1280, 2), width = 60, delay = 0, speed = 1600}
I = {ready=0}
local wtime = 0
local qtime=0
local etime=0
local qetime=0
local w_cnt = 0
local q_cnt=0
local QTarget
local Balls ={[1] = {Added = false, CanGet = false, lastQ, object, lastob},[2] = {Added = false, CanGet = false, lastQ, object, lastob},[3] = {Added = false, CanGet = false, lastQ, object, lastob},[4] = {Added = false, CanGet = false, lastQ, object, lastob},[5] = {Added = false, CanGet = false, lastQ, object, lastob},[6] = {Added = false, CanGet = false, lastQ, object, lastob}}
local MagicPen = myHero.magicPen
local MagicPenPercent = 1-myHero.magicPenPercent
local MagicArmor = 0
local RDMG={90,135,180}
local trueRDMG=0
local lastRDMG =0
local QDMG={50,95,140,185,230}
local trueQDMG=0
local lastQDMG =0
local WDMG={80,120,160,200,240}
local trueWDMG=0
local lastWDMG =0
local EDMG={70,115,160,205,250}
local trueEDMG=0
local lastEDMG =0
local igniteDMG = 0

if myHero:GetSpellData(SUMMONER_1).name:find("summonerdot") then
	Ignite = SUMMONER_1
elseif myHero:GetSpellData(SUMMONER_2).name:find("summonerdot") then
	Ignite = SUMMONER_2
end

QTS = TargetSelector(TARGET_LESS_CAST_PRIORITY, Q.range, DAMAGE_MAGIC, false)
WTS = TargetSelector(TARGET_LESS_CAST_PRIORITY, W.range, DAMAGE_MAGIC, false)
ETS = TargetSelector(TARGET_LESS_CAST_PRIORITY, E.range, DAMAGE_MAGIC, false)
RTS = TargetSelector(TARGET_LESS_CAST_PRIORITY, R.range, DAMAGE_MAGIC, false)
InterTS = TargetSelector(TARGET_LESS_CAST_PRIORITY, autoE.range, DAMAGE_MAGIC, false)
KTS = TargetSelector(TARGET_LOW_HP, Q.range, DAMAGE_MAGIC, false)
QETS = TargetSelector(TARGET_LESS_CAST_PRIORITY, QE.range, DAMAGE_MAGIC, false)
EnemyMinions = minionManager(MINION_ENEMY, W.range, player, MINION_SORT_MAXHEALTH_DEC)
JungleMobs = minionManager(MINION_JUNGLE, W.range, player, MINION_SORT_MAXHEALTH_DEC)
PosiblePets = minionManager(MINION_OTHER, W.range, myHero, MINION_SORT_MAXHEALTH_DEC)

QTarget = nil Inter=nil

function OnLoad()
	VP=VPrediction()

	Menu=scriptConfig("Fresh Syndra / KorFresh", "fresh_syndra")	
	STS = SimpleTS(STS_PRIORITY_LESS_CAST_MAGIC)
	Menu:addSubMenu("Set Target Selector Priority", "STS")
	STS:AddToMenu(Menu.STS)
	
	Menu:addSubMenu("KeySet", "KeySet")
		Menu.KeySet:addParam("ComboKey", "Combo Key", SCRIPT_PARAM_ONKEYDOWN,false,32)
		Menu.KeySet:addParam("HarassKey", "Harass Key", SCRIPT_PARAM_ONKEYDOWN,false,GetKey('C'))
		Menu.KeySet:addParam("LaneClearKey", "LaneClear & Jungle Key", SCRIPT_PARAM_ONKEYDOWN,false,GetKey('V'))
	Menu:addSubMenu("Combo", "Combo")
		Menu.Combo:addParam("UseQ", "Use Q", SCRIPT_PARAM_ONOFF, true)
		Menu.Combo:addParam("UseW", "Use W", SCRIPT_PARAM_ONOFF, true)
		Menu.Combo:addParam("UseE", "Use E", SCRIPT_PARAM_ONOFF, true)
		Menu.Combo:addParam("UseR", "Use R", SCRIPT_PARAM_ONOFF, true)
	Menu:addSubMenu("Harass", "Harass")
		Menu.Harass:addParam("UseQ", "Use Q", SCRIPT_PARAM_ONOFF, true)
		Menu.Harass:addParam("UseW", "Use W", SCRIPT_PARAM_ONOFF, true)
		Menu.Harass:addParam("UseE", "Use E", SCRIPT_PARAM_ONOFF, false)
		Menu.Harass:addParam("UseR", "Use R", SCRIPT_PARAM_ONOFF, false)
	Menu:addSubMenu("LaneClear", "LaneClear")
		Menu.LaneClear:addParam("UseQ", "Use Q", SCRIPT_PARAM_ONOFF, true)
		Menu.LaneClear:addParam("UseW", "Use W", SCRIPT_PARAM_ONOFF, true)
		Menu.LaneClear:addParam("UseE", "Use E", SCRIPT_PARAM_ONOFF, false)		
	Menu:addSubMenu("KillSteal", "KillSteal")
		Menu.KillSteal:addParam("UseQ", "Use Q", SCRIPT_PARAM_ONOFF, true)
		Menu.KillSteal:addParam("UseW", "Use W", SCRIPT_PARAM_ONOFF, true)
		Menu.KillSteal:addParam("UseE", "Use E", SCRIPT_PARAM_ONOFF, true)
		Menu.KillSteal:addParam("UseR", "Use R", SCRIPT_PARAM_ONOFF, true)		
		Menu.KillSteal:addParam("UseIgnite", "Use Ignite", SCRIPT_PARAM_ONOFF, true)
	Menu:addSubMenu("Misc", "Misc")
		Menu.Misc:addParam("QESturn", "Use Q+E CC", SCRIPT_PARAM_ONKEYDOWN, false, GetKey('T'))
		Menu.Misc:addParam("inter", "interrupt E", SCRIPT_PARAM_ONOFF, true)
		Menu.Misc:addParam("SC", "Status", SCRIPT_PARAM_ONOFF, true)
	Menu:addSubMenu("Draw","Draw")
		Menu.Draw:addParam("DrawAA", "Draw AA", SCRIPT_PARAM_ONOFF, false)
		Menu.Draw:addParam("DrawQ", "Draw Q", SCRIPT_PARAM_ONOFF, false)
		Menu.Draw:addParam("DrawW", "Draw W", SCRIPT_PARAM_ONOFF, false)
		Menu.Draw:addParam("DrawE", "Draw E", SCRIPT_PARAM_ONOFF, false)		
		Menu.Draw:addParam("DrawR", "Draw R", SCRIPT_PARAM_ONOFF, false)
		Menu.Draw:addParam("DrawQE", "Draw QE", SCRIPT_PARAM_ONOFF, false)
end

function OnCreateObj(object)
	if object.name:find("Seed") then
		GetBall(object)
	end
end

function GetBall(seed)
	for i = 1, 6, 1 do  
		if not Balls[i].Added then
			Balls[i].Added = true
			Balls[i].CanGet = true
			Balls[i].lastQ = os.clock()
			Balls[i].object = seed
			break
    		end    
	end  
end

function OnDeleteObj(object)
	if object.name:find("Syndra") and (object.name:find("_Q_idle.troy") or object.name:find("_Q_Lv5_idle.troy")) then    		
		LossBall(object)    
	end
end

function LossBall(seed)  
	for i = 1, 6, 1 do  
		if Balls[i].Added and os.clock()-Balls[i].lastQ >= 6 then
			Balls[i].Added = false
			Balls[i].CanGet = false
			Balls[i].lastQ = nil      
			Balls[i].object = nil
		end    
	end  
end

function OnDraw()
	if myHero.dead then return end
	if Menu.Draw.DrawAA then DrawCircle(myHero.x, myHero.y, myHero.z, AA.range, 0xFFFF0000)	end
	if Menu.Draw.DrawQ then DrawCircle(myHero.x, myHero.y, myHero.z, Q.range, 0xFF9c00ff) end
	if Menu.Draw.DrawW then DrawCircle(myHero.x, myHero.y, myHero.z, W.range, 0xFF0024ff) end
	if Menu.Draw.DrawE then DrawCircle(myHero.x, myHero.y, myHero.z, E.range, 0xFF00ff0c) end	
	if Menu.Draw.DrawR then DrawCircle(myHero.x, myHero.y, myHero.z, R.range, 0xFFffcc00) end
	if Menu.Draw.DrawQE then DrawCircle(myHero.x, myHero.y, myHero.z, QE.range, 0xFFFF0000) end
	if Menu.Misc.SC then
		--DrawText("Q on", 20, 1300, 720, ARGB(255, 255, 255, 255))
	end
end

function OnProcessSpell(object, spell)
	if object.isMe then
		if spell.name:find("SyndraQ") then
			qtime=os.clock()
		end 
		if spell.name:find("SyndraW") then w_cnt = 1 wtime=os.clock() end
		if spell.name:find("SyndraE") then
			etime=os.clock()			
			for i = 1, 6, 1 do  
				if Balls[i].Added then							
					Balls[i].lastob = Balls[i].object.x					
				end
			break
    			end    
		end
		if spell.name:find("syndrawcast") then w_cnt = 0 end
	end
end

function OnTick()
	Check()	
	QTarget=Target(QTS)
	WTarget=Target(WTS)
	ETarget=Target(ETS)
	RTarget=Target(RTS)
	KTarget=Target(KTS)
	QETarget=Target(QETS)
	ITarget=Target(InterTS)
	KillSteal()

	if Menu.Misc.inter then Interrupt() end
	if Menu.Misc.QESturn then if Q.ready and E.ready and ValidTarget(QETarget, QE.range) then QEcombo() end end
	if Menu.KeySet.ComboKey then Combo() end
	if Menu.KeySet.HarassKey then Harass() end
	if Menu.KeySet.LaneClearKey then LaneClear() end
end

function Check()
	if os.clock() >= (wtime+6) then w_cnt = 0 end	
	EnemyMinions:update()
	JungleMobs:update()
	PosiblePets:update()

	Q.ready = myHero:CanUseSpell(_Q) == READY
	Q.level = player:GetSpellData(_Q).level

	W.ready = myHero:CanUseSpell(_W) == READY
	W.level = player:GetSpellData(_W).level

	E.ready = myHero:CanUseSpell(_E) == READY
	E.level = player:GetSpellData(_E).level

	R.ready = myHero:CanUseSpell(_R) == READY
	R.level = player:GetSpellData(_R).level
	--if Ignite then I.ready = Ignite ~= nil and myHero:CanUseSpell(Ignite) == READY end	
	if R.level ~= 0 then trueRDMG = ((myHero.ap*0.2+RDMG[R.level])*q_cnt)+((myHero.ap*0.2+RDMG[R.level])*3) end
	if R.level==3 then R.range=750 end
	if Q.level~=0 then trueQDMG=(myHero.ap*0.6)+QDMG[Q.level] end
	if Q.level==5 then trueQDMG=((myHero.ap*0.6)+QDMG[Q.level])+(((myHero.ap*0.6)+QDMG[Q.level])*0.15) end
	if W.level~=0 then trueWDMG=(myHero.ap*0.7)+WDMG[W.level] end
	if E.level~=0 then trueEDMG=(myHero.ap*0.4)+EDMG[E.level] end
	igniteDMG = 50 + 20 * player.level

	ReactionTime = .2+GetLatency()/2000
  
	--[[
		Q = {delay = .75, range = 825, radius = 180, level = 0, ready, number = 0}
		W = {delay = .25, range = 925, range2 = 950, radius = 210, speed = 1450, level = 0, ready, state = false}
		E = {delay = .25, angle = 40, range = 650, speed = 2500, level = 0, ready}
		R = {range = 675, level = 0, ready}
		]]
	QTargetAddRange = 0
	Q.radius=180
	Balls.radius=39
	QTargetRange = Q.range+Q.radius-Balls.radius
	QTargetSpeed = 0
	QReactionTime = ReactionTime+GetLatency()/2000
	QTargetVisionPos = nil
	QTargetVisionPosRT = nil
	W.range2=950 W.radius=210
  
	if QTarget ~= nil then
  
		local AddRange = GetDistance(QTarget.minBBox, QTarget)/2
    
		QTargetAddRange = AddRange
		QTargetRange = Q.range+Q.radius-Balls.radius+AddRange
		QTargetSpeed = QTarget.ms
		QReactionTime = math.max(GetLatency()/2000, Q.delay+GetLatency()/2000-(Q.radius+QTargetAddRange)/QTargetSpeed)
    
		if QTarget.hasMovePath and QTarget.pathCount >= 2 then
			QTargetEndPos = QTarget:GetPath(2)
      
			if QTarget.pathCount >= 3 then
				QTargetEndPos = QTarget:GetPath(3)
			end
      
			QTargetVisionPos = QTarget+(Vector(QTargetEndPos)-QTarget):normalized()*QReactionTime*QTargetSpeed
			QTargetVisionPosRT = QTarget+(Vector(QTargetEndPos)-QTarget):normalized()*ReactionTime*QTargetSpeed
		end
    
	end
  
	WTargetAddRange = 0
	WTargetRange = W.range2+W.radius
	WTargetSpeed = 0
	WReactionTime = ReactionTime+GetLatency()/2000
	WTargetVisionPos = nil
	WTargetVisionPosRT = nil
  
	if WTarget ~= nil then
    
		local AddRange = GetDistance(WTarget.minBBox, WTarget)/2
    
		WTargetAddRange = AddRange
		WTargetRange = W.range2+W.radius+AddRange
		WTargetSpeed = WTarget.ms
		WReactionTime = math.max(GetLatency()/2000, (GetDistance(WTarget)+200)/W.speed+GetLatency()/2000-(W.radius+WTargetAddRange)/WTargetSpeed)
    
		if WTarget.hasMovePath and WTarget.pathCount >= 2 then
			WTargetEndPos = WTarget:GetPath(2)
      
			if WTarget.pathCount >= 3 then
				WTargetEndPos = WTarget:GetPath(3)
			end
      
			WTargetVisionPos = WTarget+(Vector(WTargetEndPos)-WTarget):normalized()*WReactionTime*WTargetSpeed
			WTargetVisionPosRT = WTarget+(Vector(WTargetEndPos)-WTarget):normalized()*ReactionTime*WTargetSpeed
		end
    
	end
end

function Combo()
	if myHero.dead then return end
	if QTarget == nil then return end

	local pos, info, hitchance
	if Q.ready and E.ready and Menu.Combo.UseQ and Menu.Combo.UseE and ValidTarget(QETarget, QE.range) then
		QEcombo()
	end		
	
	if Q.ready and Menu.Combo.UseQ and ValidTarget(QTarget, QTargetRange) then
		if (Q.delay+GetLatency()/2000)*QTargetSpeed <= Q.radius+QTargetAddRange and ValidTarget(QTarget, Q.range-Balls.radius) then
			CastQ(QTarget)
		elseif QTargetVisionPosRT and (Q.delay-ReactionTime+GetLatency()/2000)*QTargetSpeed <= Q.radius+QTargetAddRange and GetDistance(QTargetVisionPosRT) <= Q.range-Balls.radius then
			CastQ(QTargetVisionPosRT)
		elseif QTargetVisionPos and GetDistance(QTargetVisionPos) <= Q.range-Balls.radius then
			CastQ(QTargetVisionPos)
		end
	end

	if W.ready and Menu.Combo.UseW and ValidTarget(WTarget, W.range) then		
		UseSpellW(WTarget)
	end

	if R.ready and Menu.Combo.UseR and ValidTarget(KTarget, R.range) then
		UseSpellR(KTarget)		
	end
end

function Harass()
	if myHero.dead then return end
	if QTarget == nil then return end

	local pos, info, hitchance
	if Q.ready and E.ready and Menu.Harass.UseQ and Menu.Harass.UseE and ValidTarget(QETarget, QE.range) then
		QEcombo()
	end		
	
	if Q.ready and Menu.Harass.UseQ and ValidTarget(QTarget, Q.range) then
		pos, hitchance = VP:GetCircularCastPosition(QTarget, Q.delay, Q.width/2, Q.range, math.huge)
		CastSpell(_Q, pos.x, pos.z)
	end

	if W.ready and Menu.Harass.UseW and ValidTarget(WTarget, W.range) then
		UseSpellW(WTarget)
	end

	if R.ready and Menu.Harass.UseR and ValidTarget(KTarget, R.range) then		
		UseSpellR(KTarget)
	end
end

function QEcombo()
	if ValidTarget(QETarget, Q.range) then
			pos, hitchance = VP:GetCircularCastPosition(QETarget, Q.delay, Q.width/2, Q.range, math.huge)
			CastSpell(_Q, pos.x, pos.z)			
			DelayAction(function() CastSpell(_E, pos.x, pos.z) end, 0.25)
			qetime=os.clock()
			
		else
			pos, hitchance = VP:GetCircularCastPosition(QETarget, QE.delay, QE.width/2, QE.range, math.huge)
			QPos = myHero+(Vector(QTarget)-myHero):normalized()*700
			CastSpell(_Q, QPos.x, QPos.z)
			DelayAction(function() CastSpell(_E, pos.x, pos.z) end, 0.25)
			qetime=os.clock()			
	end
end

function UseSpellW(t)	
	if w_cnt==0 and W.ready then		
		for i=1,6,1 do				
			if Balls[i].object and GetDistance(Balls[i].object, myHero.object) <= W.range and Balls[i].object.x~=Balls[i].lastob and os.clock() > etime+0.75  then
				CastSpell(_W, Balls[i].object.x, Balls[i].object.z)					
			end
			break
		end
		
		for i, posiblepets in pairs(PosiblePets.objects) do
			if posiblepets == nil then return end			
			if W.ready and ValidTarget(posiblepets, W.range) and os.clock()>=qtime and os.clock() > qetime+0.25 then				
				pos, hitchance = VP:GetCircularCastPosition(posiblepets, W.delay, W.width, W.range, math.huge)
				CastSpell(_W, pos.x, pos.z)
			end
		end

		for i, minion in pairs(EnemyMinions.objects) do
			if minion == nil then return end			
			if W.ready and ValidTarget(minion, W.range) and os.clock()>=qtime and os.clock() > qetime+0.25 then				
				pos, hitchance = VP:GetCircularCastPosition(minion, W.delay, W.width, W.range, math.huge)
				CastSpell(_W, pos.x, pos.z)
			end
		end

		for i, junglemob in pairs(JungleMobs.objects) do
  			if junglemob == nil then return end
  			if W.ready and ValidTarget(junglemob, W.range) and os.clock()>=qtime and os.clock() > qetime+0.25 then
				wtime = os.clock()				
				pos, hitchance = VP:GetCircularCastPosition(junglemob, W.delay, W.width, W.range, math.huge)
				CastSpell(_W, pos.x, pos.z)
			end
		end
	end
	if w_cnt==1 then
		if t==WTarget and ValidTarget(WTarget, W.range) then
			pos, hitchance = VP:GetCircularCastPosition(WTarget, W.delay, W.width/2, W.range, math.huge)
			CastSpell(_W, pos.x, pos.z)
		end
		if t==KTarget and ValidTarget(KTarget, W.range) then
			pos, hitchance = VP:GetCircularCastPosition(KTarget, W.delay, W.width/2, W.range, math.huge)
			CastSpell(_W, pos.x, pos.z)
		end
	end
end

function UseSpellR(t)	
	if t==QTarget then
		lastRDMG = (100/(100+QTarget.magicArmor-(QTarget.magicArmor*MagicPenPercent+MagicPen)))*(trueRDMG)	
		if QTarget.health < lastRDMG then
			CastSpell(_R, QTarget)
		end
	end
	if t==KTarget then
		lastRDMG = (100/(100+KTarget.magicArmor-(KTarget.magicArmor*MagicPenPercent+MagicPen)))*(trueRDMG)	
		if KTarget.health < lastRDMG then
			CastSpell(_R, KTarget)
		end
	end
end

function KillSteal()
	if myHero.dead then return end
	if KTarget == nil then return end	
	if Menu.KillSteal.UseQ and Q.ready and ValidTarget(KTarget, Q.range) then
		lastQDMG = (100/(100+KTarget.magicArmor-(KTarget.magicArmor*MagicPenPercent+MagicPen)))*(trueQDMG)
		pos, hitchance = VP:GetCircularCastPosition(KTarget, Q.delay, Q.width/2, Q.range, math.huge)
		if KTarget.health<lastQDMG then
			CastSpell(_Q, pos.x, pos.z)
		end
	end
	if Menu.KillSteal.UseW and W.ready and ValidTarget(KTarget, W.range) then
		lastWDMG = (100/(100+KTarget.magicArmor-(KTarget.magicArmor*MagicPenPercent+MagicPen)))*(trueWDMG)
		pos, hitchance = VP:GetCircularCastPosition(KTarget, W.delay, W.width/2, W.range, math.huge)
		if KTarget.health<lastWDMG then
			UseSpellW(KTarget)
		end
	end
	if Menu.KillSteal.UseE and E.ready and  ValidTarget(KTarget, E.range) then
		lastEDMG = (100/(100+KTarget.magicArmor-(KTarget.magicArmor*MagicPenPercent+MagicPen)))*(trueEDMG)
		pos, hitchance = VP:GetCircularCastPosition(KTarget, E.delay, E.width/2, E.range, math.huge)
		if KTarget.health<lastEDMG then
			CastSpell(_E, pos.x, pos.z)
			etime=os.clock()
		end
	end
	if Menu.KillSteal.UseR and R.ready and  ValidTarget(KTarget, R.range) then
		UseSpellR(KTarget)
	end
	if Menu.KillSteal.UseIgnite and I.ready and ValidTarget(KTarget, 600) and (KTarget.health < igniteDMG) then
		CastSpell(Ignite, KTarget)
	end
end

function LaneClear()	
	for i, minion in pairs(EnemyMinions.objects) do
		if minion == nil then
			return
		end
		if Q.ready and ValidTarget(minion, Q.range) and os.clock()>=wtime and Menu.LaneClear.UseQ then
			pos, hitchance = VP:GetCircularCastPosition(minion, Q.delay, Q.width, Q.range, math.huge)
			CastSpell(_Q, pos.x, pos.z)
		end
		if W.ready and ValidTarget(minion, W.range) and os.clock()>=qtime and Menu.LaneClear.UseW then
			pos, hitchance = VP:GetCircularCastPosition(minion, W.delay, W.width, W.range, math.huge)
			CastSpell(_W, pos.x, pos.z)
		end
		if E.ready and ValidTarget(minion, E.range) and os.clock()>=qtime and Menu.LaneClear.UseE then
			pos, hitchance = VP:GetCircularCastPosition(minion, E.delay, E.width, E.range, math.huge)
			CastSpell(_Q, pos.x, pos.z)
		end
	end
	for i, junglemob in pairs(JungleMobs.objects) do
  		if junglemob == nil then
    			return
  		end
  		if Q.ready and ValidTarget(junglemob, Q.range) and os.clock()>=wtime and Menu.LaneClear.UseQ then
			pos, hitchance = VP:GetCircularCastPosition(junglemob, Q.delay, Q.width, Q.range, math.huge)
			CastSpell(_Q, pos.x, pos.z)
		end
		if W.ready and ValidTarget(junglemob, W.range) and os.clock()>=qtime and Menu.LaneClear.UseW then
			pos, hitchance = VP:GetCircularCastPosition(junglemob, W.delay, W.width, W.range, math.huge)
			CastSpell(_W, pos.x, pos.z)
		end
		if E.ready and ValidTarget(junglemob, E.range) and os.clock()>=qtime and Menu.LaneClear.UseE then
			pos, hitchance = VP:GetCircularCastPosition(junglemob, E.delay, E.width, E.range, math.huge)
			CastSpell(_Q, pos.x, pos.z)
		end		
	end
end

function Target(a) a:update() if a.target then return a.target end end

function Interrupt()
	if Q.ready and E.ready and ValidTarget(ITarget, autoE.range) then 
		pos, hitchance = VP:GetCircularCastPosition(ITarget, Q.delay, Q.width/2, autoE.range, math.huge)
		CastSpell(_Q, pos.x, pos.z)			
		DelayAction(function() CastSpell(_E, pos.x, pos.z) end, 0.25)
		qetime=os.clock()
	elseif  not Q.ready and E.ready and ValidTarget(ITarget, autoE.range) then 
		pos, hitchance = VP:GetCircularCastPosition(ITarget, E.delay, E.width/2, autoE.range, math.huge)
		CastSpell(_E, pos.x, pos.z)
	end
end

function CastQ(pos)
  
  if VIP_USER and Menu.Misc.UsePacket then
    Packet("S_CAST", {spellId = _Q, toX = pos.x, toY = pos.z, fromX = pos.x, fromY = pos.z}):send()
  else
    CastSpell(_Q, pos.x, pos.z)
  end
  
  LastQ = os.clock()   
  
end
